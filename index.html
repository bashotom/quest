<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamischer Fragebogen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4"></script>
    <script src="js/radarChart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .radar-chart .axis .line {
            stroke: #e2e8f0;
            stroke-width: 1px;
        }
        .radar-chart .area {
            fill-opacity: 0.35;
        }
        .radar-chart .circle {
            fill-opacity: 0.1;
        }
        .radar-chart .tooltip {
            font-family: 'Inter', sans-serif;
            fill: #4a5568;
        }
        @media (max-width: 640px) {
            .radar-chart text {
                font-size: 10px;
            }
            .radar-chart .axisLabel {
                font-size: 9px;
            }
            .radar-chart .axis text {
                transform: translateY(-2px);
            }
        }
        /* Definiere den Glow-Effekt */
        .radar-chart .radarStroke {
            filter: url(#glow);
        }
        .radar-chart .radarArea {
            filter: url(#glow);
        }
        .container {
            max-width: 900px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
            min-width: 90px;
        }
        th {
            background-color: #f1f5f9;
            font-weight: 500;
        }
        input[type="radio"] {
            accent-color: #3b82f6;
        }
        
        /* Answer-Block Styling */
        .answer-block {
            max-width: 500px;
        }
        
        /* Kategorien-Tabelle Animation */
        #categories-table-content {
            transition: max-height 0.3s ease-in-out;
            overflow: hidden;
        }
        
        #table-arrow {
            transition: transform 0.3s ease-in-out;
        }
        
    /* Kein horizontales Scrollen mehr auf kleinen Screens */
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div id="app" class="container mx-auto bg-white rounded-lg shadow-xl p-4 sm:p-6 md:p-8 space-y-4 sm:space-y-6 md:space-y-8 max-w-7xl">
        <!-- Top-Menü für Fragebogen-Auswahl -->
        <nav class="mb-4 sm:mb-6">
            <div class="flex flex-col sm:flex-row justify-center gap-2 sm:gap-4 items-center">
                <ul class="flex flex-wrap justify-center gap-2 sm:gap-4" id="questionnaire-menu">
                    <!-- Links werden per JS eingefügt -->
                </ul>
            </div>
            <div class="flex justify-center mt-2 sm:mt-4">
                <div class="flex flex-wrap justify-center gap-2">
                    <button id="min-answers-btn" type="button" class="border border-blue-300 bg-white hover:bg-blue-50 text-blue-700 font-medium py-1.5 px-3 rounded transition duration-150 text-xs sm:text-sm whitespace-nowrap">Alle Minimalwerte</button>
                    <button id="random-answers-btn" type="button" class="border border-blue-300 bg-white hover:bg-blue-50 text-blue-700 font-medium py-1.5 px-3 rounded transition duration-150 text-xs sm:text-sm whitespace-nowrap">Alle Zufallswerte</button>
                    <button id="max-answers-btn" type="button" class="border border-blue-300 bg-white hover:bg-blue-50 text-blue-700 font-medium py-1.5 px-3 rounded transition duration-150 text-xs sm:text-sm whitespace-nowrap">Alle Maximalwerte</button>
                </div>
            </div>
        </nav>
        <div id="questionnaire-meta" class="mb-4 text-center px-2 sm:px-4">
            <h1 id="questionnaire-title" class="text-2xl sm:text-3xl font-bold text-gray-800"></h1>
            <p id="questionnaire-description" class="text-gray-600 mt-2 text-sm sm:text-base"></p>
        </div>
        <div id="questionnaire-form">
            <div class="mb-4 flex justify-center gap-4">
                <button type="button" id="btn-column" class="border border-blue-300 bg-white hover:bg-blue-100 text-blue-700 font-medium py-1 px-3 rounded transition duration-150 text-sm">Tabellen-Modus</button>
                <button type="button" id="btn-inline" class="border border-blue-300 bg-white hover:bg-blue-100 text-blue-700 font-medium py-1 px-3 rounded transition duration-150 text-sm">Karten-Modus</button>
            </div>
            <p id="error-message" class="text-red-600 text-sm mb-4 hidden"></p>
            <form id="quiz-form">
                <!-- Oberer Auswerten-Button -->
                <div class="mb-6 sm:mb-8 flex justify-center">
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 rounded-lg transition duration-200 text-sm sm:text-base">
                        Fragebogen auswerten
                    </button>
                </div>
                <div class="questionnaire-table-scroll overflow-x-auto rounded-lg border border-gray-200 -mx-4 sm:mx-0">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead id="table-header" class="bg-gray-50"></thead>
                        <tbody id="table-body" class="bg-white divide-y divide-gray-200 text-sm sm:text-base"></tbody>
                    </table>
                </div>
                <div class="mt-6 sm:mt-8 flex justify-center">
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 rounded-lg transition duration-200 text-sm sm:text-base">
                        Fragebogen auswerten
                    </button>
                </div>
            </form>
        </div>

        <div id="evaluation-page" class="hidden">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-2">Auswertung</h2>
            <div class="flex justify-center">
                <div class="flex justify-center w-full">
                    <div class="w-full sm:w-[92%] md:w-[88%] lg:w-[85%] xl:w-[82%] radar-chart min-h-[200px] max-h-[700px] h-[min(400px,80vh)] flex justify-center items-center" id="radarChart">
                    </div>
                </div>
            </div>
            
            <!-- Kategorien-Tabelle -->
            <div id="categories-table-section" class="mt-6 sm:mt-8 px-2 sm:px-4">
                <div class="bg-white rounded-lg border border-gray-200 shadow-sm">
                    <div class="border-b border-gray-200 p-4">
                        <button id="toggle-categories-table" class="flex items-center justify-between w-full text-left font-medium text-gray-800 hover:text-blue-600 transition-colors">
                            <span class="text-lg">Kategorien-Übersicht</span>
                            <svg id="table-arrow" class="w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="categories-table-content" class="overflow-hidden">
                        <div class="p-4">
                            <div class="overflow-x-auto">
                                <table class="min-w-full border-collapse">
                                    <thead>
                                        <tr class="bg-gray-50">
                                            <th class="border border-gray-200 px-4 py-3 text-left text-sm font-medium text-gray-700">Kategorie</th>
                                            <th class="border border-gray-200 px-4 py-3 text-left text-sm font-medium text-gray-700">Punktewert</th>
                                        </tr>
                                    </thead>
                                    <tbody id="categories-table-body">
                                        <!-- Wird durch JavaScript gefüllt -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mt-6 sm:mt-8 flex flex-col items-center space-y-3 sm:space-y-4 px-2 sm:px-4">
                <h3 class="text-lg sm:text-xl font-semibold text-gray-700">Link teilen</h3>
                <div class="flex flex-col sm:flex-row w-full max-w-xl space-y-2 sm:space-y-0 sm:space-x-2">
                    <input type="text" id="share-link" readonly class="flex-grow rounded-lg border border-gray-300 px-3 sm:px-4 py-2 text-sm sm:text-base text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="copy-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 text-sm sm:text-base w-full sm:w-auto">
                        Kopieren
                    </button>
                </div>
                <button id="back-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 sm:py-3 px-4 sm:px-6 rounded-lg transition duration-200 text-sm sm:text-base w-full sm:w-auto">
                    Zurück zum Fragebogen
                </button>
            </div>
        </div>
    </div>



        <script>

        // Make radio selection on td click (column mode) — muss ganz oben stehen, damit es im onclick verfügbar ist
        window.selectRadio = function(qid, aval) {
            const radio = document.querySelector(`input[name='question-${qid}'][value='${aval}']`);
            if (radio) {
                radio.checked = true;
                // Trigger change event for listeners
                radio.dispatchEvent(new Event('change', { bubbles: true }));
            }
        };

        // Fragen dynamisch aus Datei laden


        let questionDataString = '';
        let questions = [];
        let config;


        // Hilfsfunktion: Hole alle Fragebogen-Ordner
        function getQuestionnaireFolders() {
            // Dynamisch: alle Unterordner von /quests mit questions.txt und config.json
            return [
                { name: 'Autonomie', folder: 'autonomie' },
                { name: 'ACE', folder: 'ace' },
                { name: 'Resilienz', folder: 'resilienz' }
            ];
        }

        // Prüfe, ob Debug-Modus aktiv ist
        function isDebugMode() {
            // Prüfe, ob debug=1 als Query-Parameter ODER als Hash-Parameter gesetzt ist
            const searchParams = new URLSearchParams(window.location.search);
            const hashParams = new URLSearchParams(window.location.hash.replace(/^#/, ''));
            return searchParams.get('debug') === '1' || hashParams.get('debug') === '1';
        }

        // Menü dynamisch erzeugen
        function renderQuestionnaireMenu(activeFolder) {
            const menu = document.getElementById('questionnaire-menu');
            menu.innerHTML = '';
            getQuestionnaireFolders().forEach(qb => {
                const li = document.createElement('li');
                li.innerHTML = `<a href="?q=${qb.folder}" class="px-4 py-2 rounded-lg ${activeFolder === qb.folder ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-blue-100'}">${qb.name}</a>`;
                menu.appendChild(li);
            });
            // Maximalwerte-Button immer anzeigen (keine Debug-Bedingung mehr)
        }

        // Hole aktiven Fragebogen aus Query-Parameter
        function getActiveQuestionnaire() {
            const params = new URLSearchParams(window.location.search);
            return params.get('q') || 'autonomie';
        }

        // Initialisierung
        function loadQuestionnaire() {
            const activeFolder = getActiveQuestionnaire();
            renderQuestionnaireMenu(activeFolder);
            // Baue absolute URLs für fetch, damit es überall funktioniert
            const base = window.location.origin + window.location.pathname.replace(/\/[^/]*$/, '/');
            const questionsUrl = new URL(`quests/${activeFolder}/questions.txt`, base).toString();
            const configUrl = new URL(`quests/${activeFolder}/config.json`, base).toString();
            Promise.all([
                fetch(questionsUrl).then(r => r.text()),
                fetch(configUrl).then(r => r.json())
            ]).then(([questionsText, configData]) => {
                questionDataString = questionsText;
                questions = questionDataString.split('\n').map(line => {
                    const [id, text] = line.split('|');
                    return { id, text, category: id.charAt(0) };
                });
                config = parseJsonConfig(configData);

                // Titel und Beschreibung anzeigen
                document.getElementById('questionnaire-title').textContent = config.title || 'Fragebogen';
                document.getElementById('questionnaire-description').textContent = config.description || '';

                renderQuestionnaire(config.answers);

                // Umschalt-Buttons für Darstellungsmodus nach jedem Rendern neu verbinden
                const btnColumn = document.getElementById('btn-column');
                const btnInline = document.getElementById('btn-inline');
                function updateButtonStyles() {
                    const mode = localStorage.getItem('displayMode');
                    if (btnColumn) {
                        btnColumn.classList.toggle('bg-blue-200', mode === 'column');
                        btnColumn.classList.toggle('text-black', mode === 'column');
                        btnColumn.classList.toggle('bg-white', mode !== 'column');
                        btnColumn.classList.toggle('text-gray-700', mode !== 'column');
                    }
                    if (btnInline) {
                        btnInline.classList.toggle('bg-blue-200', mode === 'inline');
                        btnInline.classList.toggle('text-black', mode === 'inline');
                        btnInline.classList.toggle('bg-white', mode !== 'inline');
                        btnInline.classList.toggle('text-gray-700', mode !== 'inline');
                    }
                }
                function restoreAnswers() {
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        const selected = document.querySelector(`input[name="question-${q.id}"]:checked`);
                        if (selected) {
                            const idx = selected.value;
                            // Nach dem Rendern wieder setzen
                            const newRadio = document.querySelector(`input[name="question-${q.id}"][value="${idx}"]`);
                            if (newRadio) newRadio.checked = true;
                        }
                    });
                    updateHighlighting();
                }
                if (btnColumn) btnColumn.onclick = () => {
                    // Antworten merken
                    const selectedMap = {};
                    questions.forEach(q => {
                        const selected = document.querySelector(`input[name="question-${q.id}"]:checked`);
                        if (selected) selectedMap[q.id] = selected.value;
                    });
                    localStorage.setItem('displayMode', 'column');
                    renderQuestionnaire(config.answers);
                    // Antworten wiederherstellen
                    questions.forEach(q => {
                        if (selectedMap[q.id] !== undefined) {
                            const newRadio = document.querySelector(`input[name="question-${q.id}"][value="${selectedMap[q.id]}"]`);
                            if (newRadio) newRadio.checked = true;
                        }
                    });
                    updateHighlighting();
                    updateButtonStyles();
                };
                if (btnInline) btnInline.onclick = () => {
                    // Antworten merken
                    const selectedMap = {};
                    questions.forEach(q => {
                        const selected = document.querySelector(`input[name="question-${q.id}"]:checked`);
                        if (selected) selectedMap[q.id] = selected.value;
                    });
                    localStorage.setItem('displayMode', 'inline');
                    renderQuestionnaire(config.answers);
                    // Antworten wiederherstellen
                    questions.forEach(q => {
                        if (selectedMap[q.id] !== undefined) {
                            const newRadio = document.querySelector(`input[name="question-${q.id}"][value="${selectedMap[q.id]}"]`);
                            if (newRadio) newRadio.checked = true;
                        }
                    });
                    updateHighlighting();
                    updateButtonStyles();
                };
                updateButtonStyles();

                // Prüfe, ob Antworten im Hash stehen (User kommt von Auswertung zurück)
                const initialScores = parseHash();
                if (initialScores) {
                    // Antworten aus dem Hash setzen
                    Object.entries(new URLSearchParams(window.location.hash.substring(1))).forEach(([qid, idx]) => {
                        const radio = document.querySelector(`input[name="question-${qid}"][value="${idx}"]`);
                        if (radio) radio.checked = true;
                    });
                    updateHighlighting();
                    renderEvaluation(initialScores, config.categories);
                } else {
                    // Nur beim ersten Laden: Zufällige Antworten auswählen
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        const randomIndex = Math.floor(Math.random() * radios.length);
                        if (radios[randomIndex]) radios[randomIndex].checked = true;
                    });
                    updateHighlighting();
                }
            });
        }

        // Starte Initialisierung
        document.addEventListener('DOMContentLoaded', loadQuestionnaire);

        // Button: Alle Antworten auf Maximalwert setzen
        document.addEventListener('DOMContentLoaded', () => {
            const maxBtn = document.getElementById('max-answers-btn');
            const minBtn = document.getElementById('min-answers-btn');
            const randomBtn = document.getElementById('random-answers-btn');
            if (maxBtn) {
                maxBtn.addEventListener('click', () => {
                    // Für jede Frage das Radio mit höchstem Index aktivieren
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        if (radios.length > 0) {
                            radios[radios.length - 1].checked = true;
                        }
                    });
                    updateHighlighting();
                });
            }
            if (minBtn) {
                minBtn.addEventListener('click', () => {
                    // Für jede Frage das Radio mit niedrigstem Index aktivieren
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        if (radios.length > 0) {
                            radios[0].checked = true;
                        }
                    });
                    updateHighlighting();
                });
            }
            if (randomBtn) {
                randomBtn.addEventListener('click', () => {
                    // Für jede Frage ein zufälliges Radio aktivieren
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        if (radios.length > 0) {
                            const randomIndex = Math.floor(Math.random() * radios.length);
                            radios[randomIndex].checked = true;
                        }
                    });
                    updateHighlighting();
                });
            }
        });

        // Bei Navigation im Menü neu laden
        window.addEventListener('popstate', loadQuestionnaire);


    // JSON-Konfiguration verarbeiten

        // JSON-Parser für die JSON-Konfigurationsdateien
        function parseJsonConfig(jsonData) {
            const result = { answers: [], categories: {}, categoriesArray: [] };
            
            // Titel und Beschreibung direkt übernehmen
            result.title = jsonData.title || '';
            result.description = jsonData.description || '';
            
            // Answers verarbeiten - aus Array von Objekten zu Array mit label/value
            if (jsonData.answers && Array.isArray(jsonData.answers)) {
                result.answers = jsonData.answers.map(answerObj => {
                    const key = Object.keys(answerObj)[0];
                    const value = answerObj[key];
                    return { label: key, value: value };
                });
            }
            
            // Categories verarbeiten - aus Array von Objekten zu Objekten und Array
            if (jsonData.categories && Array.isArray(jsonData.categories)) {
                jsonData.categories.forEach(categoryObj => {
                    const key = Object.keys(categoryObj)[0];
                    const value = categoryObj[key];
                    result.categories[key] = value;
                    result.categoriesArray.push({ key, value });
                });
            }
            
            // Chart-Konfiguration verarbeiten
            if (jsonData.chart) {
                result.chart = { ...jsonData.chart };
                result.chartConfig = { ...jsonData.chart };
                
                // Kategorie-Sortierung basierend auf "top"-Eigenschaft
                const topCategory = jsonData.chart.top;
                if (topCategory && Object.keys(result.categories).length > 1) {
                    const keys = Object.keys(result.categories);
                    const idx = keys.indexOf(topCategory);
                    if (idx > 0) {
                        const rotated = keys.slice(idx).concat(keys.slice(0, idx));
                        const newCategories = {};
                        rotated.forEach(k => { newCategories[k] = result.categories[k]; });
                        result.categories = newCategories;
                        // result.categoriesArray bleibt unverändert für die Legende
                    }
                }
            }
            
            // Input-Konfiguration verarbeiten
            if (jsonData.input) {
                result.input = { ...jsonData.input };
                // Size als Zahl parsen falls es als String vorliegt
                if (result.input.size) {
                    result.input.size = parseInt(result.input.size);
                }
            } else {
                result.input = {};
            }
            
            return result;
        }


    // Die Variablen questions und config werden jetzt nach dem Laden gesetzt

        const formElement = document.getElementById('quiz-form');
        const tableHeader = document.getElementById('table-header');
        const tableBody = document.getElementById('table-body');
        const errorMessage = document.getElementById('error-message');
        const questionnaireForm = document.getElementById('questionnaire-form');
        const evaluationPage = document.getElementById('evaluation-page');
        const backButton = document.getElementById('back-button');
        const shareLinkInput = document.getElementById('share-link');
        const copyButton = document.getElementById('copy-button');

        // Tabelle rendern
        function renderQuestionnaire(answers) {
            // Header leeren, damit kein doppelter Header entsteht
            tableHeader.innerHTML = '';
            // Dynamische Spaltenbreiten
            const fewAnswers = answers.length === 2;
            const frageThClass = fewAnswers ? 'w-3/4' : 'w-1/2';
            const answerThClass = fewAnswers ? 'w-1/8' : 'text-center';


            // User-Auswahl aus localStorage bevorzugen
            let displayMode = localStorage.getItem('displayMode');
            if (!displayMode) {
                displayMode = (config.input && config.input.display === 'inline') ? 'inline' : 'column';
            }
            // Dynamisch: Bei kleinen Screens im column-Modus auf Inline-Darstellung umschalten, außer User hat gewählt
            if (!localStorage.getItem('displayMode') && displayMode === 'column' && window.innerWidth <= 700) {
                displayMode = 'inline';
            }

        // Umschalt-Buttons für Darstellungsmodus
        document.addEventListener('DOMContentLoaded', () => {
            const btnColumn = document.getElementById('btn-column');
            const btnInline = document.getElementById('btn-inline');
            function updateButtonStyles() {
                const mode = localStorage.getItem('displayMode');
                if (btnColumn) btnColumn.classList.toggle('bg-blue-600', mode === 'column');
                if (btnColumn) btnColumn.classList.toggle('text-white', mode === 'column');
                if (btnInline) btnInline.classList.toggle('bg-blue-600', mode === 'inline');
                if (btnInline) btnInline.classList.toggle('text-white', mode === 'inline');
            }
            if (btnColumn) btnColumn.addEventListener('click', () => {
                localStorage.setItem('displayMode', 'column');
                renderQuestionnaire(config.answers);
                updateButtonStyles();
            });
            if (btnInline) btnInline.addEventListener('click', () => {
                localStorage.setItem('displayMode', 'inline');
                renderQuestionnaire(config.answers);
                updateButtonStyles();
            });
            updateButtonStyles();
        });

            if (displayMode === 'column') {
                // Header rendern (Standard)
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `<th class="${frageThClass}">Frage</th>`;
                answers.forEach(answer => {
                    headerRow.innerHTML += `<th class="${answerThClass}">${answer.label}</th>`;
                });
                tableHeader.appendChild(headerRow);
            } else {
                // Inline: Keine Tabellenheader anzeigen
                tableHeader.innerHTML = '';
            }

            // Größe der Radioboxen bestimmen
            let radioSize = 4;
            if (config.input && config.input.size) {
                // Behandle sowohl Zahlen als auch Strings
                const sizeValue = typeof config.input.size === 'string' ? 
                    parseInt(config.input.size, 10) : 
                    config.input.size;
                radioSize = Math.max(1, Math.min(5, sizeValue));
            }

            // Body rendern
            tableBody.innerHTML = '';
            questions.forEach(q => {
                const row = document.createElement('tr');
                row.id = `row-${q.id}`;
                let rowContent = '';
                    if (displayMode === 'column') {
                        rowContent = `<td class="font-medium">${q.text}</td>`;
                        answers.forEach((answer, index) => {
                            rowContent += `<td class="${answerThClass} cursor-pointer group" data-qid="${q.id}" data-aval="${index}" onclick="selectRadio('${q.id}', ${index})">
                                <div class="flex items-center justify-center h-full w-full">
                                    <label for="question-${q.id}-${index}" class="cursor-pointer w-full">
                                        <input type="radio" id="question-${q.id}-${index}" name="question-${q.id}" value="${index}" class="h-${radioSize} w-${radioSize}">
                                    </label>
                                </div>
                            </td>`;
                        });
                } else {


                    // Inline/Responsive: Frage, darunter Radioboxen untereinander
                    rowContent = `<td class="align-top">
                        <div class="text-lg font-bold text-gray-800 mb-3 leading-relaxed">${q.text}</div>
                        <div class="flex flex-col gap-1.5 mt-2 w-full">
                            ${answers.map((answer, index) => `
                                <div class=\"flex items-center gap-2 bg-gray-50 border border-gray-200 rounded-md px-3 py-1.5 transition-colors answer-block cursor-pointer hover:bg-gray-100\" data-radio-id=\"question-${q.id}-${index}\">
                                    <input type=\"radio\" id=\"question-${q.id}-${index}\" name=\"question-${q.id}\" value=\"${index}\" class=\"h-${radioSize} w-${radioSize}\">
                                    <label for=\"question-${q.id}-${index}\" class=\"cursor-pointer w-full text-sm text-gray-600\">${answer.label}</label>
                                </div>
                            `).join('')}
                        </div>
                    </td>`;
                }
                row.innerHTML = rowContent;
                tableBody.appendChild(row);
            });
            // Nach dem Rendern: Event-Listener für alle answer-blocks im Inline-Modus setzen
            if (displayMode === 'inline') {
                const blocks = tableBody.querySelectorAll('.answer-block');
                blocks.forEach(block => {
                    block.addEventListener('click', function(e) {
                        if (e.target.tagName.toLowerCase() === 'input') return;
                        const radio = block.querySelector('input[type="radio"]');
                        if (radio && !radio.checked) {
                            radio.checked = true;
                            radio.dispatchEvent(new Event('change', {bubbles:true}));
                        }
                    });
                });
            }
        }

        // Funktion zum Aktualisieren der Hervorhebung
        function updateHighlighting() {
            // Bestimme aktuellen Modus (User-Wahl oder config)
            let displayMode = localStorage.getItem('displayMode');
            if (!displayMode) {
                displayMode = (config.input && config.input.display === 'inline') ? 'inline' : 'column';
            }
            if (displayMode === 'inline') {
                // Inline: Highlight aktiven Antwortblock!
                const allBlocks = document.querySelectorAll('.answer-block');
                allBlocks.forEach(block => {
                    const radio = block.querySelector('input[type="radio"]');
                    const label = block.querySelector('label');
                    if (radio && radio.checked) {
                        block.classList.add('bg-gray-100','border-blue-300');
                        block.classList.remove('bg-gray-50','border-gray-200');
                        if (label) {
                            label.classList.add('text-blue-800','font-medium');
                            label.classList.remove('text-gray-600');
                        }
                    } else {
                        block.classList.remove('bg-gray-100','border-blue-300');
                        block.classList.add('bg-gray-50','border-gray-200');
                        if (label) {
                            label.classList.remove('text-blue-800','font-medium');
                            label.classList.add('text-gray-600');
                        }
                    }
                });
                return;
            }
            // Tabellen-Modus: Zellen mit ausgewähltem Radio farblich hervorheben
            const allCells = document.querySelectorAll('td.cursor-pointer');
            allCells.forEach(cell => {
                const radio = cell.querySelector('input[type="radio"]');
                if (radio && radio.checked) {
                    cell.classList.add('bg-blue-100');
                } else {
                    cell.classList.remove('bg-blue-100');
                }
            });
        }

        // Auswertung rendern und Chart erstellen
        function renderEvaluation(scores, categories) {

            // Buttons für Minimal/Zufall/Maximalwerte ausblenden
            const maxBtn = document.getElementById('max-answers-btn');
            const minBtn = document.getElementById('min-answers-btn');
            const randomBtn = document.getElementById('random-answers-btn');
            if (maxBtn) maxBtn.style.display = 'none';
            if (minBtn) minBtn.style.display = 'none';
            if (randomBtn) randomBtn.style.display = 'none';
            // Formular ausblenden, Auswertung anzeigen
            questionnaireForm.classList.add('hidden');
            evaluationPage.classList.remove('hidden');

            // Debug: Maximalwert anzeigen (nur im Debug-Modus)
            let maxDebug = document.getElementById('max-debug');
            if (isDebugMode()) {
                if (!maxDebug) {
                    maxDebug = document.createElement('div');
                    maxDebug.id = 'max-debug';
                    maxDebug.className = 'text-sm text-gray-500 text-center mb-2';
                    const evalHeader = evaluationPage.querySelector('h2');
                    if (evalHeader) {
                        evalHeader.insertAdjacentElement('afterend', maxDebug);
                    } else {
                        evaluationPage.prepend(maxDebug);
                    }
                }
            } else {
                if (maxDebug) maxDebug.remove();
                maxDebug = null;
            }



                // Chart-Typ aus config bestimmen
            let chartType = 'radar';
            if (config.chart && config.chart.type) {
                chartType = config.chart.type;
            }

            // Container leeren
            const container = document.getElementById('radarChart');
            container.innerHTML = '';
            
            // Container-Größe ermitteln
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;
            
            // Berechne die Maximalwerte pro Kategorie
            const categoryMaxScores = {};
            Object.keys(categories).forEach(category => {
                const categoryQuestions = questions.filter(q => q.category === category[0]);
                const maxAnswer = Math.max(...config.answers.map(a => a.value));
                categoryMaxScores[category] = categoryQuestions.length * maxAnswer;
            });

            // Berechne den Gesamtmaximalwert für Debug und andere Charts
            const maxScore = Math.max(...Object.values(categoryMaxScores));

            // Debug: Maximalwert anzeigen
            if (maxDebug) {
                maxDebug.textContent = 'Maximalwert (debug): ' + maxScore;
            }

            const labels = Object.values(categories);
            const data = Object.keys(categories).map(key => {
                const value = scores[key] || 0;
                const maxForCategory = categoryMaxScores[key];
                return (value / maxForCategory) * 100; // Normalisiere auf Prozent
            });

            // Chart-Typ ist bereits oben bestimmt
            if (chartType === 'gauge') {
                // Gauge: Zeige nur die erste Kategorie als Wert an
                const firstKey = Object.keys(categories)[0];
                const value = scores[firstKey] || 0;
                const categoryLabel = categories[firstKey];

                // SVG für Gauge erstellen
                const svg = d3.select("#radarChart")
                    .append("svg")
                    .attr("width", containerWidth)
                    .attr("height", containerHeight);

                // Gauge-Dimensionen
                const radius = Math.min(containerWidth, containerHeight) / 2;
                const centerX = containerWidth / 2;
                const centerY = containerHeight / 2;

                // Glow-Filter
                const defs = svg.append("defs");
                const filter = defs.append("filter")
                    .attr("id", "glow-gauge");
                filter.append("feGaussianBlur")
                    .attr("stdDeviation", "2.5")
                    .attr("result", "coloredBlur");
                const feMerge = filter.append("feMerge");
                feMerge.append("feMergeNode")
                    .attr("in", "coloredBlur");
                feMerge.append("feMergeNode")
                    .attr("in", "SourceGraphic");

                // Gruppe für das Gauge
                const gauge = svg.append("g")
                    .attr("transform", `translate(${centerX},${centerY})`);

                // Arc Generator für den Hintergrund
                const backgroundArc = d3.arc()
                    .innerRadius(radius * 0.7)
                    .outerRadius(radius * 0.9)
                    .startAngle(-Math.PI / 2)
                    .endAngle(Math.PI / 2);

                // Arc Generator für den Wert
                const valueArc = d3.arc()
                    .innerRadius(radius * 0.7)
                    .outerRadius(radius * 0.9)
                    .startAngle(-Math.PI / 2)
                    .endAngle(-Math.PI / 2 + Math.PI * (value / maxScore));

                // Hintergrund zeichnen
                gauge.append("path")
                    .attr("d", backgroundArc)
                    .style("fill", "#e2e8f0");

                // Wert zeichnen
                gauge.append("path")
                    .attr("d", valueArc)
                    .style("fill", "#3b82f6")
                    .style("filter", "url(#glow-gauge)");

                // Wert Text
                gauge.append("text")
                    .attr("class", "gauge-value")
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .style("font-size", "2.2rem")
                    .style("font-weight", "bold")
                    .style("font-family", "Inter, sans-serif")
                    .style("fill", "#3b82f6")
                    .text(value + " / " + maxScore);

                // Kategorie Text
                gauge.append("text")
                    .attr("class", "gauge-label")
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-size", "1.1rem")
                    .style("font-family", "Inter, sans-serif")
                    .style("fill", "#64748b")
                    .text(categoryLabel);
            } else {
                // Dynamische Schrittweite für 4-6 Skalenwerte
                let tickStep = 1;
                if (maxScore > 0) {
                    for (let s = 1; s <= maxScore; s++) {
                        const n = Math.floor(maxScore / s);
                        if (n >= 4 && n <= 6 && maxScore % s === 0) {
                            tickStep = s;
                            break;
                        }
                    }
                    // Fallback: nächstgrößere Schrittweite
                    if (tickStep === 1 && maxScore > 6) {
                        tickStep = Math.ceil(maxScore / 5);
                    }
                }
                const chartOptions = chartType === 'radar' ? {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 50,
                            right: 50,
                            top: 0,
                            bottom: 10
                        }
                    },
                    scales: {
                        r: {
                            min: 0,
                            max: maxScore,
                            pointLabels: {
                                font: {
                                    size: 20
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                display: true,
                                color: '#64748b',
                                font: { size: 13 },
                                stepSize: tickStep,
                                callback: function(value, index, values) {
                                    // Zeige nur Werte bis maxScore an
                                    if (value > maxScore) return '';
                                    return value;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                } : {
                    responsive: true,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            min: 0,
                            max: maxScore,
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                };
                if (chartType === 'radar') {
                    // Daten für D3.js RadarChart vorbereiten
                    const chartData = [
                        Object.keys(categories).map(key => ({
                            axis: { key: key, value: categories[key] },
                            value: data[Object.keys(categories).indexOf(key)]  // Verwende die bereits normalisierten Prozentwerte
                        }))
                    ];

                    // RadarChart Optionen
                    const screenWidth = window.innerWidth;
                    const responsiveOptions = {
                        // Responsive Margins basierend auf Bildschirmbreite
                        margin: screenWidth < 640 ? 
                            { top: 40, right: 40, bottom: 40, left: 40 } : 
                            { top: 50, right: 50, bottom: 50, left: 50 },
                        // Responsive Label-Faktoren
                        labelFactor: screenWidth < 640 ? 1.25 : 1.15,
                        // Kleinere Textbreite auf kleinen Bildschirmen
                        wrapWidth: screenWidth < 640 ? 100 : 80,
                    };

                    const radarChartOptions = {
                        w: containerWidth,
                        h: containerHeight,
                        ...responsiveOptions,
                        maxValue: 100, // Fester Maximalwert für Prozentanzeige
                        levels: 5,
                        roundStrokes: true,
                        color: d3.scaleOrdinal().range(['#3b82f6']),
                        dotRadius: 6,
                        opacityArea: 0.2,
                        strokeWidth: 3,
                        opacityCircles: 0.1,
                        config: config // Konfiguration für Pfeile und Tickmarks
                    };

                    // RadarChart erstellen
                    RadarChart("#radarChart", chartData, radarChartOptions);

                } else if (chartType === 'gauge') {
                    // Gauge: Zeige nur die erste Kategorie als Wert an
                    const firstKey = Object.keys(categories)[0];
                    const value = scores[firstKey] || 0;
                    const categoryLabel = categories[firstKey];

                    try {
                        // SVG für Gauge erstellen
                        const svg = d3.select("#radarChart")
                            .append("svg")
                            .attr("width", containerWidth)
                            .attr("height", containerHeight)
                            .attr("class", "gauge-chart"); // Klasse hinzufügen für Debugging

                        // Gauge-Dimensionen
                        const radius = Math.min(containerWidth, containerHeight) / 2;
                        const centerX = containerWidth / 2;
                        const centerY = containerHeight / 2;

                    // Glow-Filter
                    const defs = svg.append("defs");
                    const filter = defs.append("filter")
                        .attr("id", "glow-gauge");
                    filter.append("feGaussianBlur")
                        .attr("stdDeviation", "2.5")
                        .attr("result", "coloredBlur");
                    const feMerge = filter.append("feMerge");
                    feMerge.append("feMergeNode")
                        .attr("in", "coloredBlur");
                    feMerge.append("feMergeNode")
                        .attr("in", "SourceGraphic");

                    // Arc Generator
                    const arc = d3.arc()
                        .innerRadius(radius * 0.7)
                        .outerRadius(radius * 0.9)
                        .startAngle(-Math.PI / 2);

                    // Hintergrund-Arc
                    svg.append("path")
                        .datum({endAngle: Math.PI / 2})
                        .style("fill", "#e2e8f0")
                        .attr("d", arc)
                        .attr("transform", `translate(${centerX},${centerY})`);

                    // Wert-Arc
                    const normalizedValue = value / maxScore;
                    svg.append("path")
                        .datum({endAngle: (-Math.PI / 2) + (Math.PI * normalizedValue)})
                        .style("fill", "#3b82f6")
                        .style("filter", "url(#glow-gauge)")
                        .attr("d", arc)
                        .attr("transform", `translate(${centerX},${centerY})`);

                    // Wert Text
                    const valueText = svg.append("text")
                        .attr("class", "value-text")
                        .attr("x", centerX)
                        .attr("y", centerY)
                        .attr("text-anchor", "middle")
                        .style("font-size", "2.2rem")
                        .style("font-weight", "bold")
                        .style("font-family", "Inter, sans-serif")
                        .style("fill", "#3b82f6");

                    valueText.text(value + " / " + maxScore);

                    // Kategorie Label
                    svg.append("text")
                        .attr("x", centerX)
                        .attr("y", centerY + 32)
                        .attr("text-anchor", "middle")
                        .style("font-size", "1.1rem")
                        .style("font-family", "Inter, sans-serif")
                        .style("fill", "#64748b")
                        .text(categoryLabel);

                    } catch (error) {
                        console.error('Error creating gauge chart:', error);
                    }
                } else if (chartType === 'bar') {
                    // Balkendiagramm mit D3.js implementieren
                    const margin = {top: 20, right: 20, bottom: 30, left: 40};
                    const width = containerWidth - margin.left - margin.right;
                    const height = containerHeight - margin.top - margin.bottom;

                    const svg = d3.select("#radarChart")
                        .append("svg")
                        .attr("width", containerWidth)
                        .attr("height", containerHeight)
                        .append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);

                    const x = d3.scaleLinear()
                        .domain([0, maxScore])
                        .range([0, width]);

                    const y = d3.scaleBand()
                        .domain(Object.values(categories))
                        .range([0, height])
                        .padding(0.1);

                    svg.append("g")
                        .attr("transform", `translate(0,${height})`)
                        .call(d3.axisBottom(x));

                    svg.append("g")
                        .call(d3.axisLeft(y));

                    svg.selectAll("rect")
                        .data(Object.keys(categories))
                        .enter()
                        .append("rect")
                        .attr("y", d => y(categories[d]))
                        .attr("height", y.bandwidth())
                        .attr("x", 0)
                        .attr("width", d => x(scores[d] || 0))
                        .attr("fill", "#3b82f6");
                }
            }
            shareLinkInput.value = window.location.href;
            shareLinkInput.select();
            
            // Kategorien-Tabelle nur bei RadarChart anzeigen (nicht bei Bar oder Gauge)
            const categoriesTableSection = document.getElementById('categories-table-section');
            if (chartType === 'radar') {
                if (categoriesTableSection) {
                    categoriesTableSection.style.display = 'block';
                }
                renderCategoriesTable(scores, categories);
            } else {
                if (categoriesTableSection) {
                    categoriesTableSection.style.display = 'none';
                }
            }
        }

        // Kategorien-Tabelle rendern
        function renderCategoriesTable(scores, categories) {
            const tableBody = document.getElementById('categories-table-body');
            tableBody.innerHTML = '';
            
            // Berechne die Maximalwerte pro Kategorie für Prozentwerte
            const categoryMaxScores = {};
            Object.keys(categories).forEach(category => {
                const categoryQuestions = questions.filter(q => q.category === category[0]);
                const maxAnswer = Math.max(...config.answers.map(a => a.value));
                categoryMaxScores[category] = categoryQuestions.length * maxAnswer;
            });
            
            // Verwende config.categoriesArray für die ursprüngliche Reihenfolge
            const categoriesArray = config.categoriesArray || [];
            
            categoriesArray.forEach(categoryItem => {
                const categoryId = categoryItem.key;
                const categoryName = categoryItem.value;
                const score = scores[categoryId] || 0;
                const maxScore = categoryMaxScores[categoryId] || 1; // Fallback um Division durch 0 zu vermeiden
                const percentage = Math.round((score / maxScore) * 100);
                
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition-colors';
                row.innerHTML = `
                    <td class="border border-gray-200 px-4 py-3 text-sm text-gray-800"><span class="font-mono text-gray-600">${categoryId}:</span> ${categoryName}</td>
                    <td class="border border-gray-200 px-4 py-3 text-sm font-semibold text-blue-600">${percentage}% <span class="text-gray-500">(${score})</span></td>
                `;
                tableBody.appendChild(row);
            });
            
            // Toggle-Funktionalität für die Tabelle
            setupCategoriesTableToggle();
        }

        // Toggle-Funktionalität für Kategorien-Tabelle
        function setupCategoriesTableToggle() {
            const toggleButton = document.getElementById('toggle-categories-table');
            const tableContent = document.getElementById('categories-table-content');
            const arrow = document.getElementById('table-arrow');
            
            // Standardmäßig aufgeklappt
            let isExpanded = true;
            
            toggleButton.addEventListener('click', () => {
                isExpanded = !isExpanded;
                
                if (isExpanded) {
                    tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
                    arrow.style.transform = 'rotate(0deg)';
                } else {
                    tableContent.style.maxHeight = '0px';
                    arrow.style.transform = 'rotate(-90deg)';
                }
            });
            
            // Initial aufgeklappt setzen
            setTimeout(() => {
                tableContent.style.maxHeight = tableContent.scrollHeight + 'px';
            }, 50);
        }

        // Antworten aus dem URL-Hash parsen
        function parseHash() {
            const hash = window.location.hash.substring(1);
            if (!hash) return null;

            const scores = {};
            const params = new URLSearchParams(hash);
            let hasIncompleteData = false;
            
            for (const [key, value] of params.entries()) {
                const question = questions.find(q => q.id === key);
                if (question) {
                    const score = parseInt(value, 10);
                    if (!isNaN(score)) {
                        const category = question.category;
                        scores[category] = (scores[category] || 0) + score;
                    } else {
                        hasIncompleteData = true;
                    }
                }
            }

            if (hasIncompleteData) {
                return null;
            }

            return scores;
        }

        // Hauptlogik beim Laden der Seite


        // Die Initialisierung erfolgt jetzt ausschließlich im Promise.all oben

        // Formular-Einreichung verarbeiten
        formElement.addEventListener('submit', (event) => {
            event.preventDefault();

            const scores = {};
            let isComplete = true;
            const unansweredQuestions = [];
            const hashParams = new URLSearchParams();

            questions.forEach(q => {
                const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                let selectedRadio = null;
                radios.forEach(radio => {
                    if (radio.checked) {
                        selectedRadio = radio;
                    }
                });

                const row = document.getElementById(`row-${q.id}`);
                row.classList.remove('bg-red-100'); // Vorherige Hervorhebung entfernen

                if (selectedRadio) {
                    const answerIndex = parseInt(selectedRadio.value, 10);
                    const answerValue = config.answers[answerIndex]?.value ?? 0;
                    const category = q.category;
                    scores[category] = (scores[category] || 0) + answerValue;
                    hashParams.set(q.id, answerIndex);
                } else {
                    isComplete = false;
                    unansweredQuestions.push(q.id);
                    row.classList.add('bg-red-100'); // Zeile hervorheben
                }
            });

            if (isComplete) {
                errorMessage.classList.add('hidden');
                renderEvaluation(scores, config.categories);
                window.location.hash = hashParams.toString();
            } else {
                errorMessage.textContent = 'Bitte beantworten Sie alle Fragen.';
                errorMessage.classList.remove('hidden');
                // Zum ersten unbeantworteten Frage scrollen
                const firstUnansweredRow = document.getElementById(`row-${unansweredQuestions[0]}`);
                if (firstUnansweredRow) {
                     firstUnansweredRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        });


        // Event-Listener für Radiobox-Änderungen zur Aktualisierung der Hervorhebung
        formElement.addEventListener('change', (event) => {
            if (event.target.type === 'radio') {
                updateHighlighting();
            }
        });

    // Entfernt: Klick auf Tabellenzelle im column-Modus (verursachte Konflikte im Inline-Fallback auf kleinen Screens)

        // Event-Listener für den "Zurück"-Button
        backButton.addEventListener('click', () => {
            // Buttons für Minimal/Zufall/Maximalwerte wieder einblenden
            const maxBtn = document.getElementById('max-answers-btn');
            const minBtn = document.getElementById('min-answers-btn');
            const randomBtn = document.getElementById('random-answers-btn');
            if (maxBtn) maxBtn.style.display = '';
            if (minBtn) minBtn.style.display = '';
            if (randomBtn) randomBtn.style.display = '';
            evaluationPage.classList.add('hidden');
            questionnaireForm.classList.remove('hidden');
            // Tabelle neu rendern
            renderQuestionnaire(config.answers);
            // Antworten aus dem Hash setzen
            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            questions.forEach(q => {
                const idx = hashParams.get(q.id);
                if (idx !== null) {
                    const radio = document.querySelector(`input[name="question-${q.id}"][value="${idx}"]`);
                    if (radio) radio.checked = true;
                }
            });
            updateHighlighting();
        });

        // Event-Listener für den "Kopieren"-Button
        copyButton.addEventListener('click', () => {
            shareLinkInput.select();
            shareLinkInput.setSelectionRange(0, 99999); // Für mobile Geräte
            navigator.clipboard.writeText(shareLinkInput.value).then(() => {
                copyButton.textContent = 'Kopiert!';
                setTimeout(() => {
                    copyButton.textContent = 'Kopieren';
                }, 2000);
            }).catch(err => {
                console.error('Fehler beim Kopieren des Textes: ', err);
            });
        });

        // Beim Navigieren im Browser (z.B. zurück/vor)
        window.addEventListener('hashchange', () => {
            const scores = parseHash();
            if (scores) {
                renderEvaluation(scores, config.categories);
            } else {
                questionnaireForm.classList.remove('hidden');
                evaluationPage.classList.add('hidden');
                // Antworten aus dem Hash setzen, falls vorhanden
                Object.entries(new URLSearchParams(window.location.hash.substring(1))).forEach(([qid, idx]) => {
                    const radio = document.querySelector(`input[name="question-${qid}"][value="${idx}"]`);
                    if (radio) radio.checked = true;
                });
                updateHighlighting();
            }
        });
    </script>
</body>
</html>
