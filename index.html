<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamischer Fragebogen</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .container {
            max-width: 900px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
            min-width: 90px;
        }
        th {
            background-color: #f1f5f9;
            font-weight: 500;
        }
        input[type="radio"] {
            accent-color: #3b82f6;
        }
    /* Kein horizontales Scrollen mehr auf kleinen Screens */
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div id="app" class="container bg-white rounded-lg shadow-xl p-8 space-y-8">
        <!-- Top-Menü für Fragebogen-Auswahl -->
        <nav class="mb-6">
            <div class="flex justify-center gap-4 items-center">
                <ul class="flex gap-4" id="questionnaire-menu">
                    <!-- Links werden per JS eingefügt -->
                </ul>
                <button id="max-answers-btn" type="button" class="ml-6 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Alle Maximalwerte</button>
            </div>
        </nav>
        <div id="questionnaire-meta" class="mb-4 text-center">
            <h1 id="questionnaire-title" class="text-3xl font-bold text-gray-800"></h1>
            <p id="questionnaire-description" class="text-gray-600 mt-2"></p>
        </div>
        <div id="questionnaire-form">
            <div class="mb-4 flex justify-center gap-4">
                <button type="button" id="btn-column" class="bg-gray-200 hover:bg-blue-100 text-gray-700 font-bold py-2 px-4 rounded-lg transition duration-200">Tabellen-Modus</button>
                <button type="button" id="btn-inline" class="bg-gray-200 hover:bg-blue-100 text-gray-700 font-bold py-2 px-4 rounded-lg transition duration-200">Karten-Modus</button>
            </div>
            <p id="error-message" class="text-red-600 text-sm mb-4 hidden"></p>
            <form id="quiz-form">
                <!-- Oberer Auswerten-Button -->
                <div class="mb-8 flex justify-center">
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">
                        Fragebogen auswerten
                    </button>
                </div>
                <div class="questionnaire-table-scroll overflow-x-auto rounded-lg border border-gray-200">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead id="table-header" class="bg-gray-50"></thead>
                        <tbody id="table-body" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
                <div class="mt-8 flex justify-center">
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">
                        Fragebogen auswerten
                    </button>
                </div>
            </form>
        </div>

        <div id="evaluation-page" class="hidden">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Auswertung</h2>
            <div class="flex justify-center">
                <div class="w-full">
                    <canvas id="radarChart" style="display:block;width:100%;height:auto;"></canvas>
                </div>
            </div>
            <div class="mt-8 flex flex-col items-center space-y-4">
                <h3 class="text-xl font-semibold text-gray-700">Link teilen</h3>
                <div class="flex w-full max-w-xl space-x-2">
                    <input type="text" id="share-link" readonly class="flex-grow rounded-lg border border-gray-300 px-4 py-2 text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <button id="copy-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">
                        Kopieren
                    </button>
                </div>
                <button id="back-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-200">
                    Zurück zum Fragebogen
                </button>
            </div>
        </div>
    </div>



        <script>

        // Make radio selection on td click (column mode) — muss ganz oben stehen, damit es im onclick verfügbar ist
        window.selectRadio = function(qid, aval) {
            const radio = document.querySelector(`input[name='question-${qid}'][value='${aval}']`);
            if (radio) {
                radio.checked = true;
                // Trigger change event for listeners
                radio.dispatchEvent(new Event('change', { bubbles: true }));
            }
        };

        // Fragen dynamisch aus Datei laden


        let questionDataString = '';
        let configYamlString = '';
        let questions = [];
        let config;


        // Hilfsfunktion: Hole alle Fragebogen-Ordner
        function getQuestionnaireFolders() {
            // Dynamisch: alle Unterordner von /quests mit questions.txt und config.yml
            return [
                { name: 'Autonomie', folder: 'autonomie' },
                { name: 'ACE', folder: 'ace' },
                { name: 'Resilienz', folder: 'resilienz' }
            ];
        }

        // Prüfe, ob Debug-Modus aktiv ist
        function isDebugMode() {
            // Prüfe, ob debug=1 als Query-Parameter ODER als Hash-Parameter gesetzt ist
            const searchParams = new URLSearchParams(window.location.search);
            const hashParams = new URLSearchParams(window.location.hash.replace(/^#/, ''));
            return searchParams.get('debug') === '1' || hashParams.get('debug') === '1';
        }

        // Menü dynamisch erzeugen
        function renderQuestionnaireMenu(activeFolder) {
            const menu = document.getElementById('questionnaire-menu');
            menu.innerHTML = '';
            getQuestionnaireFolders().forEach(qb => {
                const li = document.createElement('li');
                li.innerHTML = `<a href="?q=${qb.folder}" class="px-4 py-2 rounded-lg ${activeFolder === qb.folder ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-blue-100'}">${qb.name}</a>`;
                menu.appendChild(li);
            });
            // Maximalwerte-Button nur im Debug-Modus anzeigen
            const maxBtn = document.getElementById('max-answers-btn');
            if (maxBtn) {
                maxBtn.style.display = isDebugMode() ? '' : 'none';
            }
        }

        // Hole aktiven Fragebogen aus Query-Parameter
        function getActiveQuestionnaire() {
            const params = new URLSearchParams(window.location.search);
            return params.get('q') || 'autonomie';
        }

        // Initialisierung
        function loadQuestionnaire() {
            const activeFolder = getActiveQuestionnaire();
            renderQuestionnaireMenu(activeFolder);
            // Baue absolute URLs für fetch, damit es überall funktioniert
            const base = window.location.origin + window.location.pathname.replace(/\/[^/]*$/, '/');
            const questionsUrl = new URL(`quests/${activeFolder}/questions.txt`, base).toString();
            const configUrl = new URL(`quests/${activeFolder}/config.yml`, base).toString();
            Promise.all([
                fetch(questionsUrl).then(r => r.text()),
                fetch(configUrl).then(r => r.text())
            ]).then(([questionsText, configText]) => {
                questionDataString = questionsText;
                configYamlString = configText;
                questions = questionDataString.split('\n').map(line => {
                    const [id, text] = line.split('|');
                    return { id, text, category: id.charAt(0) };
                });
                config = parseYaml(configYamlString);

                // Titel und Beschreibung anzeigen
                document.getElementById('questionnaire-title').textContent = config.title || 'Fragebogen';
                document.getElementById('questionnaire-description').textContent = config.description || '';

                renderQuestionnaire(config.answers);

                // Umschalt-Buttons für Darstellungsmodus nach jedem Rendern neu verbinden
                const btnColumn = document.getElementById('btn-column');
                const btnInline = document.getElementById('btn-inline');
                function updateButtonStyles() {
                    const mode = localStorage.getItem('displayMode');
                    if (btnColumn) {
                        btnColumn.classList.toggle('bg-blue-600', mode === 'column');
                        btnColumn.classList.toggle('text-white', mode === 'column');
                        btnColumn.classList.toggle('bg-gray-200', mode !== 'column');
                        btnColumn.classList.toggle('text-gray-700', mode !== 'column');
                    }
                    if (btnInline) {
                        btnInline.classList.toggle('bg-blue-600', mode === 'inline');
                        btnInline.classList.toggle('text-white', mode === 'inline');
                        btnInline.classList.toggle('bg-gray-200', mode !== 'inline');
                        btnInline.classList.toggle('text-gray-700', mode !== 'inline');
                    }
                }
                if (btnColumn) btnColumn.onclick = () => {
                    localStorage.setItem('displayMode', 'column');
                    renderQuestionnaire(config.answers);
                    updateButtonStyles();
                };
                if (btnInline) btnInline.onclick = () => {
                    localStorage.setItem('displayMode', 'inline');
                    renderQuestionnaire(config.answers);
                    updateButtonStyles();
                };
                updateButtonStyles();

                // Prüfe, ob Antworten im Hash stehen (User kommt von Auswertung zurück)
                const initialScores = parseHash();
                if (initialScores) {
                    // Antworten aus dem Hash setzen
                    Object.entries(new URLSearchParams(window.location.hash.substring(1))).forEach(([qid, idx]) => {
                        const radio = document.querySelector(`input[name="question-${qid}"][value="${idx}"]`);
                        if (radio) radio.checked = true;
                    });
                    updateHighlighting();
                    renderEvaluation(initialScores, config.categories);
                } else {
                    // Nur beim ersten Laden: Zufällige Antworten auswählen
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        const randomIndex = Math.floor(Math.random() * radios.length);
                        if (radios[randomIndex]) radios[randomIndex].checked = true;
                    });
                    updateHighlighting();
                }
            });
        }

        // Starte Initialisierung
        document.addEventListener('DOMContentLoaded', loadQuestionnaire);

        // Button: Alle Antworten auf Maximalwert setzen
        document.addEventListener('DOMContentLoaded', () => {
            const maxBtn = document.getElementById('max-answers-btn');
            if (maxBtn) {
                maxBtn.addEventListener('click', () => {
                    // Für jede Frage das Radio mit höchstem Index aktivieren
                    questions.forEach(q => {
                        const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                        if (radios.length > 0) {
                            radios[radios.length - 1].checked = true;
                        }
                    });
                    updateHighlighting();
                });
            }
        });

        // Bei Navigation im Menü neu laden
        window.addEventListener('popstate', loadQuestionnaire);


    // configYamlString wird jetzt dynamisch geladen

        // Einfacher YAML-Parser für die spezifische Struktur
        function parseYaml(yamlString) {
            const lines = yamlString.split('\n').filter(line => line.trim() !== '');
            const result = { answers: [], categories: {} };
            let currentSection = '';

            let topCategory = null;
            let chartType = null;
            let inChartObject = false;
            let inInputObject = false;
            result.input = {};
            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine.startsWith('title:')) {
                    result.title = trimmedLine.replace('title:', '').trim();
                    continue;
                }
                if (trimmedLine.startsWith('description:')) {
                    result.description = trimmedLine.replace('description:', '').trim();
                    continue;
                }
                if (trimmedLine === 'answers:') {
                    currentSection = 'answers';
                    continue;
                }
                if (trimmedLine === 'categories:') {
                    currentSection = 'categories';
                    continue;
                }
                if (trimmedLine === 'chart:') {
                    currentSection = 'chart';
                    inChartObject = true;
                    continue;
                }
                if (inChartObject && (trimmedLine.startsWith('type:') || trimmedLine.startsWith('top:'))) {
                    const [key, value] = trimmedLine.split(':');
                    if (key.trim() === 'type') chartType = value.trim();
                    if (key.trim() === 'top') topCategory = value.trim();
                    continue;
                }
                if (inChartObject && !trimmedLine.startsWith(' ')) {
                    inChartObject = false;
                }
                if (trimmedLine === 'input:') {
                    currentSection = 'input';
                    inInputObject = true;
                    continue;
                }
                if (inInputObject && (trimmedLine.startsWith('element:') || trimmedLine.startsWith('size:') || trimmedLine.startsWith('display:'))) {
                    const [key, value] = trimmedLine.split(':');
                    result.input[key.trim()] = value.trim();
                    continue;
                }
                if (inInputObject && !trimmedLine.startsWith(' ')) {
                    inInputObject = false;
                }

                if (currentSection === 'answers') {
                    if (trimmedLine.startsWith('- ')) {
                        // Format: - label: value
                        const parts = trimmedLine.substring(2).split(':');
                        if (parts.length === 2) {
                            result.answers.push({
                                label: parts[0].trim(),
                                value: parseFloat(parts[1].trim())
                            });
                        } else {
                            // Fallback: Nur Label
                            result.answers.push({ label: trimmedLine.substring(2).trim(), value: 0 });
                        }
                    }
                } else if (currentSection === 'categories') {
                    if (trimmedLine.startsWith('- ')) {
                        const parts = trimmedLine.substring(2).split(':');
                        if (parts.length === 2) {
                            const key = parts[0].trim();
                            const value = parts[1].trim();
                            result.categories[key] = value;
                        }
                    }
                }
            }
            if (chartType) result.chartType = chartType;
            // Sortiere categories, falls topCategory gesetzt
            if (topCategory && Object.keys(result.categories).length > 1) {
                const keys = Object.keys(result.categories);
                const idx = keys.indexOf(topCategory);
                if (idx > 0) {
                    const rotated = keys.slice(idx).concat(keys.slice(0, idx));
                    const newCategories = {};
                    rotated.forEach(k => { newCategories[k] = result.categories[k]; });
                    result.categories = newCategories;
                }
            }
            return result;
        }


    // Die Variablen questions und config werden jetzt nach dem Laden gesetzt

        const formElement = document.getElementById('quiz-form');
        const tableHeader = document.getElementById('table-header');
        const tableBody = document.getElementById('table-body');
        const errorMessage = document.getElementById('error-message');
        const questionnaireForm = document.getElementById('questionnaire-form');
        const evaluationPage = document.getElementById('evaluation-page');
        const backButton = document.getElementById('back-button');
        const shareLinkInput = document.getElementById('share-link');
        const copyButton = document.getElementById('copy-button');

        let myChart = null; // Variable für das Chart.js-Instanz

        // Tabelle rendern
        function renderQuestionnaire(answers) {
            // Header leeren, damit kein doppelter Header entsteht
            tableHeader.innerHTML = '';
            // Dynamische Spaltenbreiten
            const fewAnswers = answers.length === 2;
            const frageThClass = fewAnswers ? 'w-3/4' : 'w-1/2';
            const answerThClass = fewAnswers ? 'w-1/8' : 'text-center';


            // User-Auswahl aus localStorage bevorzugen
            let displayMode = localStorage.getItem('displayMode');
            if (!displayMode) {
                displayMode = (config.input && config.input.display === 'inline') ? 'inline' : 'column';
            }
            // Dynamisch: Bei kleinen Screens im column-Modus auf Inline-Darstellung umschalten, außer User hat gewählt
            if (!localStorage.getItem('displayMode') && displayMode === 'column' && window.innerWidth <= 700) {
                displayMode = 'inline';
            }

        // Umschalt-Buttons für Darstellungsmodus
        document.addEventListener('DOMContentLoaded', () => {
            const btnColumn = document.getElementById('btn-column');
            const btnInline = document.getElementById('btn-inline');
            function updateButtonStyles() {
                const mode = localStorage.getItem('displayMode');
                if (btnColumn) btnColumn.classList.toggle('bg-blue-600', mode === 'column');
                if (btnColumn) btnColumn.classList.toggle('text-white', mode === 'column');
                if (btnInline) btnInline.classList.toggle('bg-blue-600', mode === 'inline');
                if (btnInline) btnInline.classList.toggle('text-white', mode === 'inline');
            }
            if (btnColumn) btnColumn.addEventListener('click', () => {
                localStorage.setItem('displayMode', 'column');
                renderQuestionnaire(config.answers);
                updateButtonStyles();
            });
            if (btnInline) btnInline.addEventListener('click', () => {
                localStorage.setItem('displayMode', 'inline');
                renderQuestionnaire(config.answers);
                updateButtonStyles();
            });
            updateButtonStyles();
        });

            if (displayMode === 'column') {
                // Header rendern (Standard)
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `<th class="${frageThClass}">Frage</th>`;
                answers.forEach(answer => {
                    headerRow.innerHTML += `<th class="${answerThClass}">${answer.label}</th>`;
                });
                tableHeader.appendChild(headerRow);
            } else {
                // Inline: Nur eine Spalte für Frage+Antworten
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `<th class="${frageThClass}">Frage</th>`;
                tableHeader.appendChild(headerRow);
            }

            // Größe der Radioboxen bestimmen
            let radioSize = 4;
            if (config.input && config.input.size) {
                const match = config.input.size.match(/([+-]?\d+)/);
                if (match) {
                    radioSize = Math.max(1, Math.min(5, 4 + parseInt(match[1], 10)));
                }
            }

            // Body rendern
            tableBody.innerHTML = '';
            questions.forEach(q => {
                const row = document.createElement('tr');
                row.id = `row-${q.id}`;
                let rowContent = '';
                    if (displayMode === 'column') {
                        rowContent = `<td class="font-medium">${q.text}</td>`;
                        answers.forEach((answer, index) => {
                            rowContent += `<td class="${answerThClass} cursor-pointer group" data-qid="${q.id}" data-aval="${index}" onclick="selectRadio('${q.id}', ${index})">
                                <div class="flex items-center justify-center h-full w-full">
                                    <label for="question-${q.id}-${index}" class="cursor-pointer w-full">
                                        <input type="radio" id="question-${q.id}-${index}" name="question-${q.id}" value="${index}" class="h-${radioSize} w-${radioSize}">
                                    </label>
                                </div>
                            </td>`;
                        });
                } else {


                    // Inline/Responsive: Frage, darunter Radioboxen untereinander
                    rowContent = `<td class="font-medium align-top">
                        <div>${q.text}</div>
                        <div class="flex flex-col gap-2 mt-2 w-full">
                            ${answers.map((answer, index) => `
                                <div class=\"flex items-center gap-2 bg-blue-50 border border-blue-200 rounded-lg px-4 py-2 transition-colors answer-block cursor-pointer\" data-radio-id=\"question-${q.id}-${index}\">
                                    <input type=\"radio\" id=\"question-${q.id}-${index}\" name=\"question-${q.id}\" value=\"${index}\" class=\"h-${radioSize} w-${radioSize}\">
                                    <label for=\"question-${q.id}-${index}\" class=\"cursor-pointer w-full\">${answer.label}</label>
                                </div>
                            `).join('')}
                        </div>
                    </td>`;
                }
                row.innerHTML = rowContent;
                tableBody.appendChild(row);
            });
            // Nach dem Rendern: Event-Listener für alle answer-blocks im Inline-Modus setzen
            if (displayMode === 'inline') {
                const blocks = tableBody.querySelectorAll('.answer-block');
                blocks.forEach(block => {
                    block.addEventListener('click', function(e) {
                        if (e.target.tagName.toLowerCase() === 'input') return;
                        const radio = block.querySelector('input[type="radio"]');
                        if (radio && !radio.checked) {
                            radio.checked = true;
                            radio.dispatchEvent(new Event('change', {bubbles:true}));
                        }
                    });
                });
            }
        }

        // Funktion zum Aktualisieren der Hervorhebung
        function updateHighlighting() {
            // Bestimme aktuellen Modus (User-Wahl oder config)
            let displayMode = localStorage.getItem('displayMode');
            if (!displayMode) {
                displayMode = (config.input && config.input.display === 'inline') ? 'inline' : 'column';
            }
            if (displayMode === 'inline') {
                // Inline: Highlight aktiven Antwortblock
                const allBlocks = document.querySelectorAll('.answer-block');
                allBlocks.forEach(block => {
                    const radio = block.querySelector('input[type="radio"]');
                    if (radio && radio.checked) {
                        block.classList.add('bg-blue-400','text-white');
                        block.classList.remove('bg-blue-50','text-gray-900','bg-blue-500');
                    } else {
                        block.classList.remove('bg-blue-400','text-white','bg-blue-500');
                        block.classList.add('bg-blue-50','text-gray-900');
                    }
                });
                return;
            }
            // Im Column-Modus keine Hervorhebung der Tabellenzelle mehr
            // (früher: cell.classList.add('bg-blue-100'))
        }

        // Auswertung rendern und Chart erstellen
        function renderEvaluation(scores, categories) {

            // Maximalwerte-Button ausblenden
            const maxBtn = document.getElementById('max-answers-btn');
            if (maxBtn) maxBtn.style.display = 'none';
            // Formular ausblenden, Auswertung anzeigen
            questionnaireForm.classList.add('hidden');
            evaluationPage.classList.remove('hidden');

            // Debug: Maximalwert anzeigen (nur im Debug-Modus)
            let maxDebug = document.getElementById('max-debug');
            if (isDebugMode()) {
                if (!maxDebug) {
                    maxDebug = document.createElement('div');
                    maxDebug.id = 'max-debug';
                    maxDebug.className = 'text-sm text-gray-500 text-center mb-2';
                    const evalHeader = evaluationPage.querySelector('h2');
                    if (evalHeader) {
                        evalHeader.insertAdjacentElement('afterend', maxDebug);
                    } else {
                        evaluationPage.prepend(maxDebug);
                    }
                }
            } else {
                if (maxDebug) maxDebug.remove();
                maxDebug = null;
            }



            // Chart-Typ aus config
            let chartType = 'radar';
            if (config.chartType === 'bar') chartType = 'bar';
            if (config.chartType === 'gauge') chartType = 'gauge';

            // Canvas-Größe für RadarChart dynamisch anpassen
            const radarCanvas = document.getElementById('radarChart');
            if (chartType === 'radar') {
                // Maximal 40vw breit und maximal 55vh hoch (quadratisch, aber nicht größer als Viewport)
                const maxWidth = Math.floor(window.innerWidth * 0.4);
                const maxHeight = Math.floor(window.innerHeight * 0.55);
                const size = Math.min(maxWidth, maxHeight);
                radarCanvas.width = size;
                radarCanvas.height = size;
            } else {
                radarCanvas.width = 400;
                radarCanvas.height = 400;
            }
            const ctx = radarCanvas.getContext('2d');

            // Alten Chart zerstören, falls vorhanden
            if (myChart) {
                myChart.destroy();
            }


            // Dynamischen Maximalwert für die Achse berechnen
            const maxScores = {};
            questions.forEach(q => {
                // Maximalwert: Summe der größten Werte pro Frage
                const maxAnswer = Math.max(...config.answers.map(a => a.value));
                maxScores[q.category] = (maxScores[q.category] || 0) + maxAnswer;
            });
            const maxScore = Math.max(...Object.values(maxScores));

            // Debug: Maximalwert anzeigen
            if (maxDebug) {
                maxDebug.textContent = 'Maximalwert (debug): ' + maxScore;
            }

            const labels = Object.values(categories);
            const data = Object.keys(categories).map(key => scores[key] || 0);

            // Chart-Typ ist bereits oben bestimmt
            if (chartType === 'gauge') {
                // Gauge: Zeige nur die erste Kategorie als Wert an
                const firstKey = Object.keys(categories)[0];
                const value = scores[firstKey] || 0;
                const categoryLabel = categories[firstKey];
                // Plugin für zentrale Wertanzeige und Kategoriename
                const gaugeValuePlugin = {
                    id: 'gaugeValuePlugin',
                    afterDraw: chart => {
                        const { ctx, chartArea } = chart;
                        ctx.save();
                        ctx.font = 'bold 2.2rem Inter, Arial, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#3b82f6';
                        const centerX = (chartArea.left + chartArea.right) / 2;
                        // Y-Position etwas niedriger (optisch mittig im Halbkreis)
                        const centerY = chartArea.top + (chartArea.bottom - chartArea.top) * 0.65;
                        ctx.fillText(value + ' / ' + maxScore, centerX, centerY);
                        // Kategoriename darunter kleiner anzeigen
                        ctx.font = '1.1rem Inter, Arial, sans-serif';
                        ctx.fillStyle = '#64748b';
                        ctx.fillText(categoryLabel, centerX, centerY + 32);
                        ctx.restore();
                    }
                };
                myChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: [categories[firstKey], ''],
                        datasets: [{
                            data: [value, Math.max(maxScore - value, 0)],
                            backgroundColor: [
                                'rgba(59, 130, 246, 0.8)',
                                'rgba(203, 213, 225, 0.5)'
                            ],
                            borderWidth: 0
                        }]
                    },
                    options: {
                        rotation: -90,
                        circumference: 180,
                        cutout: '70%',
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        }
                    },
                    plugins: [gaugeValuePlugin]
                });
            } else {
                // Dynamische Schrittweite für 4-6 Skalenwerte
                let tickStep = 1;
                if (maxScore > 0) {
                    for (let s = 1; s <= maxScore; s++) {
                        const n = Math.floor(maxScore / s);
                        if (n >= 4 && n <= 6 && maxScore % s === 0) {
                            tickStep = s;
                            break;
                        }
                    }
                    // Fallback: nächstgrößere Schrittweite
                    if (tickStep === 1 && maxScore > 6) {
                        tickStep = Math.ceil(maxScore / 5);
                    }
                }
                const chartOptions = chartType === 'radar' ? {
                    responsive: true,
                    scales: {
                        r: {
                            min: 0,
                            max: maxScore,
                            pointLabels: {
                                font: {
                                    size: 20
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            ticks: {
                                display: true,
                                color: '#64748b',
                                font: { size: 13 },
                                stepSize: tickStep,
                                callback: function(value, index, values) {
                                    // Zeige nur Werte bis maxScore an
                                    if (value > maxScore) return '';
                                    return value;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                } : {
                    responsive: true,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            min: 0,
                            max: maxScore,
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                };
                myChart = new Chart(ctx, {
                    type: chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Ergebnis',
                            data: data,
                            backgroundColor: chartType === 'radar' ? 'rgba(59, 130, 246, 0.2)' : 'rgba(59, 130, 246, 0.5)',
                            borderColor: 'rgb(59, 130, 246)',
                            pointBackgroundColor: chartType === 'radar' ? 'rgb(59, 130, 246)' : undefined,
                            pointBorderColor: chartType === 'radar' ? '#fff' : undefined,
                            pointHoverBackgroundColor: chartType === 'radar' ? '#fff' : undefined,
                            pointHoverBorderColor: chartType === 'radar' ? 'rgb(59, 130, 246)' : undefined,
                            borderWidth: 2
                        }]
                    },
                    options: chartOptions
                });
            }
            shareLinkInput.value = window.location.href;
            shareLinkInput.select();
        }

        // Antworten aus dem URL-Hash parsen
        function parseHash() {
            const hash = window.location.hash.substring(1);
            if (!hash) return null;

            const scores = {};
            const params = new URLSearchParams(hash);
            let hasIncompleteData = false;
            
            for (const [key, value] of params.entries()) {
                const question = questions.find(q => q.id === key);
                if (question) {
                    const score = parseInt(value, 10);
                    if (!isNaN(score)) {
                        const category = question.category;
                        scores[category] = (scores[category] || 0) + score;
                    } else {
                        hasIncompleteData = true;
                    }
                }
            }

            if (hasIncompleteData) {
                return null;
            }

            return scores;
        }

        // Hauptlogik beim Laden der Seite


        // Die Initialisierung erfolgt jetzt ausschließlich im Promise.all oben

        // Formular-Einreichung verarbeiten
        formElement.addEventListener('submit', (event) => {
            event.preventDefault();

            const scores = {};
            let isComplete = true;
            const unansweredQuestions = [];
            const hashParams = new URLSearchParams();

            questions.forEach(q => {
                const radios = document.querySelectorAll(`input[name="question-${q.id}"]`);
                let selectedRadio = null;
                radios.forEach(radio => {
                    if (radio.checked) {
                        selectedRadio = radio;
                    }
                });

                const row = document.getElementById(`row-${q.id}`);
                row.classList.remove('bg-red-100'); // Vorherige Hervorhebung entfernen

                if (selectedRadio) {
                    const answerIndex = parseInt(selectedRadio.value, 10);
                    const answerValue = config.answers[answerIndex]?.value ?? 0;
                    const category = q.category;
                    scores[category] = (scores[category] || 0) + answerValue;
                    hashParams.set(q.id, answerIndex);
                } else {
                    isComplete = false;
                    unansweredQuestions.push(q.id);
                    row.classList.add('bg-red-100'); // Zeile hervorheben
                }
            });

            if (isComplete) {
                errorMessage.classList.add('hidden');
                renderEvaluation(scores, config.categories);
                window.location.hash = hashParams.toString();
            } else {
                errorMessage.textContent = 'Bitte beantworten Sie alle Fragen.';
                errorMessage.classList.remove('hidden');
                // Zum ersten unbeantworteten Frage scrollen
                const firstUnansweredRow = document.getElementById(`row-${unansweredQuestions[0]}`);
                if (firstUnansweredRow) {
                     firstUnansweredRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        });


        // Event-Listener für Radiobox-Änderungen zur Aktualisierung der Hervorhebung
        formElement.addEventListener('change', (event) => {
            if (event.target.type === 'radio') {
                updateHighlighting();
            }
        });

    // Entfernt: Klick auf Tabellenzelle im column-Modus (verursachte Konflikte im Inline-Fallback auf kleinen Screens)

        // Event-Listener für den "Zurück"-Button
        backButton.addEventListener('click', () => {
            // Maximalwerte-Button wieder einblenden
            const maxBtn = document.getElementById('max-answers-btn');
            if (maxBtn) maxBtn.style.display = '';
            evaluationPage.classList.add('hidden');
            questionnaireForm.classList.remove('hidden');
            // Tabelle neu rendern
            renderQuestionnaire(config.answers);
            // Antworten aus dem Hash setzen
            const hashParams = new URLSearchParams(window.location.hash.substring(1));
            questions.forEach(q => {
                const idx = hashParams.get(q.id);
                if (idx !== null) {
                    const radio = document.querySelector(`input[name="question-${q.id}"][value="${idx}"]`);
                    if (radio) radio.checked = true;
                }
            });
            updateHighlighting();
        });

        // Event-Listener für den "Kopieren"-Button
        copyButton.addEventListener('click', () => {
            shareLinkInput.select();
            shareLinkInput.setSelectionRange(0, 99999); // Für mobile Geräte
            navigator.clipboard.writeText(shareLinkInput.value).then(() => {
                copyButton.textContent = 'Kopiert!';
                setTimeout(() => {
                    copyButton.textContent = 'Kopieren';
                }, 2000);
            }).catch(err => {
                console.error('Fehler beim Kopieren des Textes: ', err);
            });
        });

        // Beim Navigieren im Browser (z.B. zurück/vor)
        window.addEventListener('hashchange', () => {
            const scores = parseHash();
            if (scores) {
                renderEvaluation(scores, config.categories);
            } else {
                questionnaireForm.classList.remove('hidden');
                evaluationPage.classList.add('hidden');
                // Antworten aus dem Hash setzen, falls vorhanden
                Object.entries(new URLSearchParams(window.location.hash.substring(1))).forEach(([qid, idx]) => {
                    const radio = document.querySelector(`input[name="question-${qid}"][value="${idx}"]`);
                    if (radio) radio.checked = true;
                });
                updateHighlighting();
            }
        });
    </script>
</body>
</html>
